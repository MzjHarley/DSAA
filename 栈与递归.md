---
title: 函数递归
date: 2021-01-15 14:37:20
tags:
categories:
- C语言
---
Read more.
<!--more-->
# 递归
定义：函数直接或间接调用自己；
## 函数为什么可以自己调用自己？
前提：函数的调用是通过栈实现的；
## 一个函数在运行期间去调用其它函数，在运行被调函数前需做三件事
1.将所有实参、返回地址（下一条指令的地址）等信息传给被调函数保存；
2.为被调函数的局部变量分配内存（包括形参）；
3.将控制转移到被调函数的入口从而执行被调函数；
## 从被调函数转移到主调函数前系统也需做三件事
1.保存被调函数返回的结果；
2.释放被调函数所占用的内存空间（系统收回被调用函数占用的内存空间的使用权限）；
3.依照被调函数所保存的返回地址，将控制转移到主调函数（从被调函数跳出）；

**当多个函数相互调用时，按照“后调用先返回”的原则，函数间的信息传递和控制转移必须借助栈来实现。即整个程序运行所需的数据空间安排在一个栈中。每调用一个函数时，就在栈顶分配一个存储区进行压栈操作，每当一个函数退出时，就释放它的存储区即出栈。当前运行的函数永远在栈顶。在计算机看来，函数A调用函数B 和 函数A调用函数A是没有区别的。（执行步骤相同）**
## 注意
不能无限压栈和出栈，否则系统会崩溃；
### 递归必须满足两个条件
1.递归必须有明确的终止条件；
2.该函数所处理的数据规模必须在递减；n->n-1->n-2->n-3->...->1
### 递归和循环的关系
所有循环都可转化为递归；所有递归不一定能由循环实现；
### 递归和循环优缺点
#### 递归
优点：易于理解；
缺点：速度慢、存储空间大（浪费空间多）；
#### 循环
优点：速度快、存储空间小（浪费空间少）；
缺点：不易理解；
## 递归应用
树和森林以递归方式定义；
树和图的很多算法都是以递归实现；
很多数学公式都是以递归方式定义的，如斐波拉契数列；
## 递归之流程解析
```c
#include<stdio.h>
int f(int);//函数声明可不加形参，但必须末尾有引号；
int main()
{
   int i=f(3);
   printf("i=%d\n",i);
   return 0;
}
int f(int i)
{
    if(i==1)
       printf("哈哈\n");
    else
       i= f(i-1);
    return i;
}
输出：哈哈
      i=1
```
函数调用流程：
f(3)->i=f(2)->i=f(1)->f(1)输出 哈哈;
return 1->f(1)完成->i=1->return 1->f(2)完成->i=1->return 1->f(3)完成;
跳出f函数 输出1；
## 递归之汉诺塔
```c
#include<stdio.h>
void hannuota(int i,char A ,char B,char C)
{
    if(i==1)
       printf("将编号为%d的盘子从%c移到%c\n",i,A,C);
    else
    {
       hannuota(i-1,A,C,B);//将i-1个盘从A借助C移到B；
       printf("将编号为%d的盘子从%c移到%c\n",i,A,C);//将编号为i的盘从A移到C;
       hannuota(i-1,B,A,C);//将i-1个盘从B借助A移到C;
    }
}
int main()
{
    int i;
    printf("请为盘子的个数赋值：");
    scanf("%d",&i);
    hannuota(i,'A','B','C');
    return 0;
}
```
## 递归之阶乘
```c
#include<stdio.h>
int f(int i)
{
    if(i==1)
      return 1;
    else
      return i*f(i-1);
}
int main()
{
    int i;
    char ch;
    do
    {
     printf("请输入你想求的阶乘数：");
     scanf("%d",&i);
     printf("%d的阶乘为%d\n",i,f(i));
     printf("你是否还要继续（Y/N）:");
     scanf(" %c",&ch);
    }while(ch=='Y');
    return 0;
}
```